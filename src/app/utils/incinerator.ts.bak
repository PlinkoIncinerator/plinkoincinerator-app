import { Config } from "../config/solana";
import { PublicKey } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";

// Export the types and functions from the new modules
export * from "./tokenMetadata";
export * from "./tokenAccounts";
import { burnTokens } from "./tokenBurner";
export { burnTokens as incinerateTokens } from "./tokenBurner"; // Alias for backward compatibility
import { batchBurnTokens } from "./batchTokenBurner";
export { batchBurnTokens as batchIncinerateTokens } from "./batchTokenBurner"; // Alias for backward compatibility

// Re-export Config for convenience
export { Config };

// Types for token metadata
export interface TokenMetadata {
  name: string;
  symbol: string;
  image: string;
  mint: string;
  priceUsd?: number;
}

// Cache for token metadata to avoid repeated API calls
const tokenMetadataCache: Record<string, TokenMetadata> = {};

// Fetch token metadata from DexScreener API
export async function getTokenMetadata(mintAddress: string): Promise<TokenMetadata> {
  // Return from cache if available
  if (tokenMetadataCache[mintAddress]) {
    return tokenMetadataCache[mintAddress];
  }
  
  try {
    // Use DexScreener API to get token metadata
    const url = `https://api.dexscreener.com/latest/dex/tokens/${mintAddress}`;
    console.log(`Fetching metadata for ${mintAddress} from DexScreener`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch token metadata: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (!data || !data.pairs || data.pairs.length === 0) {
      // If DexScreener has no data and token ends with 'pump', try Pump.fun API
      if (mintAddress.toLowerCase().endsWith('pump')) {
        console.log(`No DexScreener data found for ${mintAddress}, trying Pump.fun API`);
        return await getPumpFunMetadata(mintAddress);
      }
      console.log(`No DexScreener data found for ${mintAddress}`);
      throw new Error("No metadata found");
    }
    
    // Get the first pair data which contains token info
    const tokenData = data.pairs[0];
    console.log("Debug: DexScreener token data:", tokenData);
    
    // Use the image URL from the info section if available
    let imageUrl = '';
    if (tokenData.info && tokenData.info.imageUrl) {
      imageUrl = tokenData.info.imageUrl;
    } else {
      // Fallback to generic source
      imageUrl = `https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/${mintAddress}/logo.png`;
    }
    
    // Get price in USD if available
    // priceUsd is the price per token in USD
    const priceUsd = tokenData.priceUsd ? parseFloat(tokenData.priceUsd) : undefined;
    console.log(`Debug: Token ${mintAddress} price per token: $${priceUsd}`);
    
    const result: TokenMetadata = {
      name: tokenData.baseToken.name || 'Unknown Token',
      symbol: tokenData.baseToken.symbol || '???',
      image: imageUrl,
      mint: mintAddress,
      priceUsd: priceUsd
    };
    
    // Cache the result
    tokenMetadataCache[mintAddress] = result;
    console.log(`Cached metadata for ${mintAddress}:`, result);
    return result;
  } catch (error) {
    console.error(`Error fetching metadata for ${mintAddress}:`, error);
    
    // If token ends with 'pump', try Pump.fun API as fallback
    if (mintAddress.toLowerCase().endsWith('pump')) {
      try {
        return await getPumpFunMetadata(mintAddress);
      } catch (pumpError) {
        console.error(`Error fetching from Pump.fun API: ${pumpError}`);
      }
    }
   
    // Fallback to basic metadata
    const fallbackMetadata: TokenMetadata = {
      name: `Token ${mintAddress.slice(0, 4)}...${mintAddress.slice(-4)}`,
      symbol: '???',
      image: '',
      mint: mintAddress,
    };
    
    // Cache the fallback result
    tokenMetadataCache[mintAddress] = fallbackMetadata;
    return fallbackMetadata;
  }
}

// Function to fetch metadata from Pump.fun API
async function getPumpFunMetadata(mintAddress: string): Promise<TokenMetadata> {
  const url = `https://frontend-api-v3.pump.fun/coins/${mintAddress}`;
  console.log(`Fetching metadata for ${mintAddress} from Pump.fun API`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': '*/*',
      'Accept-Language': 'en-US,en;q=0.5',
      'Content-Type': 'application/json',
      'Origin': 'https://pump.fun',
      'Referer': 'https://pump.fun/',
      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Failed to fetch from Pump.fun API: ${response.statusText}`);
  }
  
  const data = await response.json();
  console.log("Debug: Pump.fun token data:", data);
  
  // Calculate price per token in USD
  // market_cap is in USD, total_supply is the total token supply
  const priceUsd = data.market_cap && data.total_supply 
    ? data.market_cap / (data.total_supply / Math.pow(10, 9)) // Convert from raw amount to actual tokens
    : undefined;
  
  console.log(`Debug: Token ${mintAddress} price per token from Pump.fun: $${priceUsd}`);
  
  const result: TokenMetadata = {
    name: data.name || `Token ${mintAddress.slice(0, 4)}...${mintAddress.slice(-4)}`,
    symbol: data.symbol || '???',
    image: data.image_uri || '',
    mint: mintAddress,
    priceUsd: priceUsd
  };
  
  // Cache the result
  tokenMetadataCache[mintAddress] = result;
  console.log(`Cached Pump.fun metadata for ${mintAddress}:`, result);
  return result;
}

// Batch fetch token metadata for multiple tokens
export async function batchGetTokenMetadata(mintAddresses: string[]): Promise<Record<string, TokenMetadata>> {
  // Using a map to track promises for each address
  const metadataPromises: Record<string, Promise<TokenMetadata>> = {};
  
  // Filter out mints we already have in cache
  for (const mint of mintAddresses) {
    if (tokenMetadataCache[mint]) {
      continue; // Skip if already in cache
    }
    
    // Create a promise for each token's metadata
    metadataPromises[mint] = getTokenMetadata(mint);
  }
  
  // Wait for all promises to resolve
  if (Object.keys(metadataPromises).length > 0) {
    try {
      const mintAddressesArray = Object.keys(metadataPromises);
      const promisesArray = Object.values(metadataPromises);
      
      console.log(`Fetching metadata for ${mintAddressesArray.length} tokens`);
      
      // Resolve all promises
      const results = await Promise.allSettled(promisesArray);
      
      // Process results
      results.forEach((result, index) => {
        const mintAddress = mintAddressesArray[index];
        
        if (result.status === 'fulfilled') {
          // Successful result is already cached in getTokenMetadata
        } else {
          console.error(`Failed to fetch metadata for ${mintAddress}:`, result.reason);
          // Create fallback for failures
          tokenMetadataCache[mintAddress] = {
            name: `Token ${mintAddress.slice(0, 4)}...${mintAddress.slice(-4)}`,
            symbol: '???',
            image: '',
            mint: mintAddress,
          };
        }
      });
    } catch (error) {
      console.error("Error batch fetching token metadata:", error);
    }
  }
  
  // Return metadata for all requested mints from cache
  return mintAddresses.reduce((acc, mint) => {
    acc[mint] = tokenMetadataCache[mint] || {
      name: `Token ${mint.slice(0, 4)}...${mint.slice(-4)}`,
      symbol: '???',
      image: '',
      mint: mint,
    };
    return acc;
  }, {} as Record<string, TokenMetadata>);
}

// Tokens that should not be incinerated
export const blacklist = [
  "EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm", // Example: USDC
  "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // Example: USDT
];

export interface TokenAccountData {
  info: {
    isNative: boolean;
    mint: string;
    owner: string;
    state: string;
    tokenAmount: {
      amount: string;
      decimals: number;
      uiAmount: number;
      uiAmountString: string;
    };
  };
}

export interface TokenAccount {
  pubkey: PublicKey;
  account: {
    data: {
      parsed: TokenAccountData;
    };
  };
}

// For tracking the progress of token account fetching
export type FetchProgressCallback = (stage: string, progress: number, message?: string) => void;

export async function getTokenAccounts(progressCallback?: FetchProgressCallback): Promise<TokenAccount[]> {
  if (!Config.solWallet.publicKey) {
    return [];
  }
  
  // Notify progress if callback provided
  const notifyProgress = (stage: string, progress: number, message?: string) => {
    if (progressCallback) {
      progressCallback(stage, progress, message);
    }
  };
  
  console.log("Fetching token accounts for wallet:", Config.solWallet.publicKey.toString());
  console.log("Using RPC URL:", (Config.connection as any)._rpcEndpoint);
  
  // Create a timeout promise that rejects after the specified duration
  const createTimeoutPromise = (ms: number, method: string) => {
    return new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`RPC timeout after ${ms/1000}s while executing ${method}`));
      }, ms);
    });
  };
  
  // Try multiple methods to get token accounts, with fallbacks
  let accounts: TokenAccount[] = [];
  
  notifyProgress('init', 10, 'Initializing token account scan');
  
  // Attempt 1: Use getParsedTokenAccountsByOwner with spl-token programId filter
  try {
    console.log("Attempt 1: Using getParsedTokenAccountsByOwner with TOKEN_PROGRAM_ID filter");
    notifyProgress('accounts', 20, 'Attempting primary scan method');
    
    try {
      // Increase timeout to 30 seconds to allow more time for RPC response
      const atas = await Promise.race([
        Config.connection.getParsedTokenAccountsByOwner(
          Config.solWallet.publicKey,
          { programId: TOKEN_PROGRAM_ID }
        ) as any,
        createTimeoutPromise(30000, 'getParsedTokenAccountsByOwner')
      ]);
      
      if (atas?.value?.length > 0) {
        console.log(`Found ${atas.value.length} token accounts with attempt 1`);
        notifyProgress('accounts', 70, `Found ${atas.value.length} token accounts`);
        accounts = atas.value;
        return accounts;
      } else {
        notifyProgress('accounts', 30, 'No accounts found, trying fallback method');
      }
    } catch (error) {
      // Check for specific RPC errors and provide more helpful messages
      const errorMessage = String(error);
      if (errorMessage.includes('timeout')) {
        console.error("RPC timeout on first attempt - network congestion");
        notifyProgress('error', 30, 'Network congestion - trying fallback method');
      } else if (errorMessage.includes('429')) {
        console.error("RPC rate limit exceeded");
        notifyProgress('error', 30, 'Rate limit exceeded - trying fallback method');
      } else if (errorMessage.includes('503')) {
        console.error("RPC service unavailable");
        notifyProgress('error', 30, 'Service unavailable - trying fallback method');
      } else {
        console.error("Error with attempt 1:", error);
        notifyProgress('error', 30, 'Connection error - trying fallback method');
      }
    }
  } catch (err) {
    console.error("General error with attempt 1:", err);
    notifyProgress('error', 30, 'Error in primary scan - trying fallback method');
  }
  
  // Attempt 2: Using getTokenAccountsByOwner
  try {
    console.log("Attempt 2: Using getTokenAccountsByOwner");
    notifyProgress('accounts', 40, 'Trying alternative method (1/3)');
    
    try {
      // Using 25 seconds timeout for second attempt
      const response = await Promise.race([
        Config.connection.getTokenAccountsByOwner(
          Config.solWallet.publicKey,
          { programId: TOKEN_PROGRAM_ID }
        ) as any,
        createTimeoutPromise(25000, 'getTokenAccountsByOwner')
      ]);
      
      if (response?.value?.length > 0) {
        console.log(`Found ${response.value.length} token accounts with attempt 2`);
        notifyProgress('accounts', 70, `Found ${response.value.length} token accounts`);
        
        // Convert to the expected format
        accounts = response.value.map((item: any) => {
          const accountInfo = item.account;
          return {
            pubkey: item.pubkey,
            account: {
              data: {
                parsed: {
                  info: {
                    mint: new PublicKey(accountInfo.data.slice(0, 32)).toString(),
                    owner: Config.solWallet.publicKey!.toString(),
                    tokenAmount: {
                      amount: "0",
                      decimals: 0,
                      uiAmount: 0,
                      uiAmountString: "0"
                    }
                  }
                }
              }
            }
          } as any;
        });
        
        return accounts;
      } else {
        notifyProgress('accounts', 50, 'No accounts found, trying next method');
      }
    } catch (error) {
      const errorMessage = String(error);
      if (errorMessage.includes('timeout')) {
        console.error("RPC timeout on second attempt");
        notifyProgress('error', 50, 'Network congestion persists - trying final methods');
      } else {
        console.error("Error with attempt 2:", error);
        notifyProgress('error', 50, 'Error in second scan - trying final methods');
      }
    }
  } catch (err) {
    console.error("General error with attempt 2:", err);
    notifyProgress('error', 50, 'Error in fallback scan - trying final method');
  }
  
  // Attempt 3: Using getProgramAccounts with memcmp filter
  try {
    console.log("Attempt 3: Using getProgramAccounts with memcmp filter");
    notifyProgress('accounts', 60, 'Trying fallback method (2/3)');
    
    try {
      // Using 20 seconds timeout for third attempt
      const programAccounts = await Promise.race([
        Config.connection.getProgramAccounts(
          TOKEN_PROGRAM_ID,
          {
            filters: [
              { dataSize: 165 }, // Size of token account data
              {
                memcmp: {
                  offset: 32, // Owner offset in token account data
                  bytes: Config.solWallet.publicKey.toBase58(),
                },
              },
            ],
          }
        ) as any,
        createTimeoutPromise(20000, 'getProgramAccounts with memcmp')
      ]);
      
      if (programAccounts?.length > 0) {
        console.log(`Found ${programAccounts.length} token accounts with attempt 3`);
        notifyProgress('accounts', 80, `Found ${programAccounts.length} token accounts`);
        
        // Convert the raw account data to our format
        accounts = programAccounts.map((account: any) => {
          const data = account.account.data;
          // Basic parsing of SPL token data
          return {
            pubkey: account.pubkey,
            account: {
              data: {
                parsed: {
                  info: {
                    mint: new PublicKey(data.slice(0, 32)).toString(),
                    owner: Config.solWallet.publicKey!.toString(),
                    tokenAmount: {
                      amount: "0", // We're going to assume it's an empty account
                      decimals: 0,
                      uiAmount: 0,
                      uiAmountString: "0"
                    }
                  }
                }
              }
            }
          } as any;
        });
        
        return accounts;
      } else {
        notifyProgress('accounts', 65, 'No accounts found, trying final method');
      }
    } catch (error) {
      const errorMessage = String(error);
      if (errorMessage.includes('timeout')) {
        notifyProgress('error', 65, 'Network congestion continues - trying final method');
      } else {
        notifyProgress('error', 65, 'Error in third scan - one more method to try');
      }
    }
  } catch (err) {
    console.error("General error with attempt 3:", err);
    notifyProgress('error', 65, 'Error in third scan - trying final method');
  }
  
  // Attempt 4: Using getProgramAccounts with only dataSize filter
  try {
    console.log("Attempt 4: Using getProgramAccounts with only dataSize filter");
    notifyProgress('accounts', 75, 'Trying final fallback method (3/3)');
    
    try {
      // Using 15 seconds timeout for last attempt - more limited approach
      const programAccounts = await Promise.race([
        Config.connection.getProgramAccounts(
          TOKEN_PROGRAM_ID,
          {
            filters: [
              { dataSize: 165 }, // Size of token account data
            ],
            commitment: 'confirmed',
          }
        ) as any,
        createTimeoutPromise(15000, 'getProgramAccounts basic')
      ]);
      
      if (programAccounts?.length > 0) {
        console.log(`Found ${programAccounts.length} token accounts with attempt 4`);
        notifyProgress('accounts', 85, `Found ${programAccounts.length} potential accounts, filtering...`);
        
        // Filter for accounts owned by the wallet
        const filteredAccounts = programAccounts.filter((account: any) => {
          try {
            const data = account.account.data;
            const ownerAddress = new PublicKey(data.slice(32, 64)).toString();
            return ownerAddress === Config.solWallet.publicKey!.toString();
          } catch (err) {
            return false;
          }
        });
        
        console.log(`After filtering, found ${filteredAccounts.length} accounts owned by wallet`);
        notifyProgress('accounts', 90, `Found ${filteredAccounts.length} token accounts after filtering`);
        
        if (filteredAccounts.length > 0) {
          // Convert the raw account data to our format
          accounts = filteredAccounts.map((account: any) => {
            const data = account.account.data;
            // Basic parsing of SPL token data
            return {
              pubkey: account.pubkey,
              account: {
                data: {
                  parsed: {
                    info: {
                      mint: new PublicKey(data.slice(0, 32)).toString(),
                      owner: Config.solWallet.publicKey!.toString(),
                      tokenAmount: {
                        amount: "0", // We're going to assume it's an empty account
                        decimals: 0,
                        uiAmount: 0,
                        uiAmountString: "0"
                      }
                    }
                  }
                }
              }
            } as any;
          });
          
          return accounts;
        } else {
          notifyProgress('accounts', 95, 'No matching accounts found after filtering');
        }
      } else {
        notifyProgress('accounts', 95, 'No token accounts found with any method');
      }
    } catch (error) {
      const errorMessage = String(error);
      if (errorMessage.includes('timeout')) {
        notifyProgress('error', 95, 'Network connection issues during final scan attempt');
      } else {
        notifyProgress('error', 95, 'Error in final scan method');
      }
    }
  } catch (err) {
    console.error("Error with attempt 4:", err);
    notifyProgress('error', 95, 'All scan methods failed');
  }
  
  console.warn("All attempts to fetch token accounts failed");
  notifyProgress('error', 100, 'Unable to scan token accounts. Network may be congested.');
  
  // For development/demo purposes: Generate mock data when all RPC calls fail
  // This is useful for testing the UI when RPC endpoints are down or rate-limited
  if (process.env.NODE_ENV !== 'production' || window.location.hostname === 'localhost') {
    console.log("Generating mock data for development/demo purposes");
    notifyProgress('accounts', 100, 'Using mock data for development purposes');
    
    // Create 5 mock token accounts
    const mockAccounts = Array.from({ length: 5 }, (_, i) => {
      const randomMint = `${Math.random().toString(36).substring(2, 10)}${Math.random().toString(36).substring(2, 10)}`;
      const randomPubkey = `${Math.random().toString(36).substring(2, 10)}${Math.random().toString(36).substring(2, 10)}`;
      
      return {
        pubkey: {
          toString: () => randomPubkey
        },
        account: {
          data: {
            parsed: {
              info: {
                mint: randomMint,
                owner: Config.solWallet.publicKey!.toString(),
                tokenAmount: {
                  amount: "0",
                  decimals: 0,
                  uiAmount: 0,
                  uiAmountString: "0"
                }
              }
            }
          }
        }
      } as any;
    });
    
    return mockAccounts;
  }
  
  return [];
}

export async function incinerateTokens(
  selectedTokens?: string[],
  dynamicWallet?: any, // Dynamic wallet parameter
  directWithdrawal: boolean = false // Whether to direct withdraw (true) or gamble (false)
): Promise<{
  success: boolean;
  message: string;
  signature?: string;
  feeTransferSignature?: string;
  totalAmount?: number;
  closedCount?: number;
}> {
  try {
    if (!Config.solWallet.publicKey) {
      return {
        success: false,
        message: "Wallet not connected",
        closedCount: 0,
      };
    }

    // Check if we have a wallet to sign transactions
    if (!dynamicWallet && !Config.solWallet.payer) {
      return {
        success: false,
        message: "No wallet available to sign transactions. Please provide a Dynamic wallet or configure a keypair.",
        closedCount: 0,
      };
    }

    const atas = await Config.connection.getParsedTokenAccountsByOwner(
      Config.solWallet.publicKey,
      {
        programId: TOKEN_PROGRAM_ID,
      }
    );

    // Filter accounts based on selectedTokens if provided
    let accountsToProcess = atas.value;
    if (selectedTokens && selectedTokens.length > 0) {
      // If specific tokens are selected, only process those
      accountsToProcess = atas.value.filter(ata => {
        const data = (ata.account.data.parsed as TokenAccountData).info;
        return selectedTokens.includes(ata.pubkey.toString());
      });
    }

    // Calculate approximate SOL return (0.00203928 SOL per token account closed)
    const expectedReturnPerAccount = 0.00203928;
    // Limit to 5 token accounts at once to reduce transaction size and complexity
    const accountsToClose = Math.min(accountsToProcess.length, 5);
    
    if (accountsToClose === 0) {
      return {
        success: false,
        message: "No token accounts available to incinerate",
        closedCount: 0,
      };
    }

    const totalEligibleAccounts = accountsToProcess.length;
    const isBatch = totalEligibleAccounts > accountsToClose;
    
    const expectedReturn = expectedReturnPerAccount * accountsToClose;
    const feeAmount = expectedReturn * Config.FEE_PERCENTAGE;
    
    // Always ensure the fee wallet is set
    if (!Config.FEE_WALLET) {
      return {
        success: false,
        message: "Fee wallet not properly configured.",
        closedCount: 0,
      };
    }
    
    // STEP 1: Incinerate token accounts
    console.log(`Preparing to incinerate ${accountsToClose} token accounts...`);
    if (isBatch) {
      console.log(`Processing as batch ${accountsToClose} of ${totalEligibleAccounts} eligible accounts`);
    }
    console.log(`Mode: ${directWithdrawal ? 'Direct Withdrawal' : 'Gambling'}`);
    
    // Initialize the instructions array with the compute budget instructions
    const incinerateInstructions = [
      ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 10000 }),
      ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
    ];

    let closedCount = 0;
    
    // Process selected token accounts (up to 5)
    for (const ata of accountsToProcess.slice(0, 5)) {
      const data = (ata.account.data.parsed as TokenAccountData).info;
      
      // Skip blacklisted tokens
      if (blacklist.includes(data.mint)) continue;
      
      // Skip accounts with non-zero balance
      if (data.tokenAmount.amount !== "0") {
        const amount = data.tokenAmount.amount; // in base units
        const decimals = data.tokenAmount.decimals;
        const amountInBaseUnits = parseInt(amount);
        const tokenAmount = parseFloat(data.tokenAmount.uiAmountString || '0');
        
        console.log(`Token ${data.mint} amount: ${tokenAmount} ${data.mint.slice(0, 4)}`);
        
        // Define helper function once for all code paths to use
        const burnAndCloseAccount = () => {
          // First burn remaining tokens (required before closing non-empty account)
          if (amountInBaseUnits > 0) {
            incinerateInstructions.push(
              createBurnInstruction(
                ata.pubkey,                    // Token account
                new PublicKey(data.mint),      // Mint
                Config.solWallet.publicKey!,   // Owner - using non-null assertion
                amountInBaseUnits              // Amount to burn
              )
            );
            console.log(`Burning ${tokenAmount} tokens from mint ${data.mint}`);
          }
          
          // Then close the account
          incinerateInstructions.push(
            createCloseAccountInstruction(
              ata.pubkey,
              Config.solWallet.publicKey!,     // Using non-null assertion
              Config.solWallet.publicKey!      // Using non-null assertion
            )
          );
          console.log("Incinerating token:", data.mint);
        };
        
        // Set up for Jupiter quote
        const inputMint = data.mint;
        const outputMint = "So11111111111111111111111111111111111111112"; // SOL

        // Get Jupiter quote to determine SOL value
        const queryParams = new URLSearchParams({
          inputMint: inputMint,
          outputMint: outputMint,
          amount: amountInBaseUnits.toString(),
          slippageBps: '100'
        }).toString();
        
        const quoteUrl = `https://lite-api.jup.ag/swap/v1/quote?${queryParams}`;
        
        try {
          const quoteRes = await fetch(quoteUrl);
          const quoteData = await quoteRes.json();
          
          // Check if we successfully got a valid quote that we can use
          if (quoteRes.ok && !quoteData.errorCode) {
            // Extract expected output amount in lamports (SOL's smallest unit)
            const outAmount = quoteData.outAmount;
            const outAmountInSol = parseInt(outAmount) / 1_000_000_000; // Convert lamports to SOL
            
            console.log(`Token ${data.mint} estimated value: ${outAmountInSol} SOL`);
            
            // Check if token value is too small to justify swap costs
            // We need to consider both absolute value and value relative to token amount
            const valuePerToken = outAmountInSol / tokenAmount;
            console.log(`Value per token: ${valuePerToken.toExponential(6)} SOL (${tokenAmount} tokens)`);
            
            // Consider a token low value if:
            // 1. Absolute value is less than 0.000005 SOL (~$0.0001 at $20 SOL price) OR
            // 2. Value per token is extremely low (below 0.00000000001 SOL per token) AND total value below 0.0001 SOL
            if (outAmountInSol < 0.000005 || (valuePerToken < 0.00000000001 && outAmountInSol < 0.0001)) {
              console.log(`Token ${data.mint} has negligible value (${outAmountInSol} SOL), proceeding with burn and close`);
              
              // Handle as low value - burn tokens and close account
              burnAndCloseAccount();
              closedCount++;
              continue;
            }
            
            // Check if the swap route is too complex (has too many hops)
            if (quoteData?.routePlan && quoteData.routePlan.length > 2) {
              console.log(`Route too complex for ${data.mint}, defaulting to burn and close`);
              
              // Handle as low value - burn tokens and close account
              burnAndCloseAccount();
              closedCount++;
              continue;
            }

            // Get swap instructions for successful Jupiter quote
            const swapReq = {
              quoteResponse: quoteData,
              userPublicKey: Config.solWallet.publicKey.toString(),
              wrapUnwrapSOL: true
            };
            const swapRes = await fetch("https://lite-api.jup.ag/swap/v1/swap-instructions", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(swapReq)
            });
            
            if (!swapRes.ok) {
              console.log(`Failed to get swap instructions for ${data.mint}, defaulting to burn and close`);
              
              // Handle as low value - burn tokens and close account
              burnAndCloseAccount();
              closedCount++;
              continue;
            }
            
            const swapInstructions = await swapRes.json();

            // Validate the swap instructions structure
            if (!swapInstructions || 
                !swapInstructions.swapInstruction || 
                !swapInstructions.swapInstruction.accounts ||
                !swapInstructions.swapInstruction.data ||
                !swapInstructions.swapInstruction.programId) {
              console.log(`Invalid swap instruction format for ${data.mint}, defaulting to burn and close`);
              
              // Handle as low value - burn tokens and close account
              burnAndCloseAccount();
              closedCount++;
              continue;
            }

            // Add all Jupiter instructions to your transaction
            for (const ix of [
              ...(swapInstructions.setupInstructions || []),
              swapInstructions.swapInstruction,
              ...(swapInstructions.cleanupInstruction ? [swapInstructions.cleanupInstruction] : [])
            ]) {
              try {
                // Convert raw Jupiter instruction to TransactionInstruction
                const keys = ix.accounts.map((acc: any) => ({
                  pubkey: new PublicKey(acc.pubkey),
                  isSigner: acc.isSigner,
                  isWritable: acc.isWritable
                }));
                
                const programId = new PublicKey(ix.programId);
                
                // Safely decode the data
                let data;
                try {
                  // Handle different data formats from Jupiter API
                  if (typeof ix.data === 'string') {
                    // If data is base64 string
                    data = Buffer.from(ix.data, 'base64');
                  } else if (ix.data instanceof Uint8Array) {
                    // If data is already a Uint8Array
                    data = Buffer.from(ix.data);
                  } else if (Array.isArray(ix.data)) {
                    // If data is array of numbers
                    data = Buffer.from(ix.data);
                  } else {
                    console.log("Unknown data format:", ix.data);
                    // Skip this instruction if data format is unknown
                    continue;
                  }
                } catch (dataError) {
                  console.error("Error decoding instruction data:", dataError);
                  console.log("Problematic data:", ix.data);
                  // Skip this instruction
                  continue;
                }
                
                const transactionInstruction = new TransactionInstruction({
                  keys,
                  programId,
                  data
                });
                
                incinerateInstructions.push(transactionInstruction);
              } catch (ixError) {
                console.error("Error processing instruction:", ixError);
                // Skip this instruction and continue with others
                continue;
              }
            }

            // Add close account instruction after swap
            incinerateInstructions.push(
              createCloseAccountInstruction(
                ata.pubkey,
                Config.solWallet.publicKey!,     // Using non-null assertion
                Config.solWallet.publicKey!      // Using non-null assertion
              )
            );
            console.log("Incinerating token:", data.mint);
            closedCount++;
          } else {
            // Jupiter returned a valid response but couldn't find a route
            // or returned an error - try to use token metadata
            console.log(`Jupiter API error for ${data.mint}: ${quoteData.error || quoteData.errorCode || 'Unknown error'}`);
            
            try {
              // Try getting the token metadata which might have price info
              const tokenMetadata = await getTokenMetadata(data.mint);
              
              if (tokenMetadata.priceUsd) {
                // If we have USD price, we can calculate SOL value
                // Assume 1 SOL = $20 if we don't have exact price
                const solPrice = 20; 
                
                // Calculate estimated SOL value
                const estimatedValueInSol = (tokenMetadata.priceUsd * tokenAmount) / solPrice;
                console.log(`Token ${data.mint} metadata-estimated value: ${estimatedValueInSol} SOL`);
                
                // Check if token value is too small to justify swap costs
                if (estimatedValueInSol < 0.000005 || (estimatedValueInSol / tokenAmount < 0.00000000001 && estimatedValueInSol < 0.0001)) {
                  console.log(`Token ${data.mint} has negligible value based on metadata, proceeding with burn and close`);
                  
                  // Handle as low value - burn tokens and close account
                  burnAndCloseAccount();
                  closedCount++;
                  continue;
                } else {
                  // This is the only case where we skip a token - when we know it has significant value
                  // but we can't swap it through Jupiter
                  console.log(`Token ${data.mint} has significant value (${estimatedValueInSol} SOL) but no swap route. Skipping.`);
                  continue;
                }
              } else {
                // No price data in metadata, default to burn and close
                console.log(`No price data found for ${data.mint}, defaulting to burn and close`);
                
                // Handle as low value - burn tokens and close account
                burnAndCloseAccount();
                closedCount++;
                continue;
              }
            } catch (metadataError) {
              // Error fetching metadata, default to burn and close
              console.log(`Error fetching metadata for ${data.mint}, defaulting to burn and close`);
              
              // Handle as low value - burn tokens and close account
              burnAndCloseAccount();
              closedCount++;
              continue;
            }
          }
        } catch (error) {
          console.error(`Error getting quote for ${data.mint}:`, error);
          
          // For network/API errors, default to burn and close
          console.log(`Error occurred for ${data.mint}, defaulting to burn and close`);
          
          // Handle as low value - burn tokens and close account
          burnAndCloseAccount();
          closedCount++;
          continue;
        }
      }
    }
    
    if (closedCount === 0) {
      return {
        success: false,
        message: "No eligible token accounts to incinerate",
        closedCount: 0,
      };
    }

    // If this is a direct withdrawal, add a fee transfer instruction to the incineration transaction
    // For gambling mode, we also include the fee transfer but send the full amount to the fee wallet
    if (directWithdrawal) {
      console.log(`Adding fee transfer of ${feeAmount} SOL to ${Config.FEE_WALLET.toString()} in the same transaction`);
      
      // Create fee transfer instruction directly in the incineration transaction
      incinerateInstructions.push(
        SystemProgram.transfer({
          fromPubkey: Config.solWallet.publicKey,
          toPubkey: Config.FEE_WALLET,
          lamports: Math.floor(feeAmount * 1_000_000_000), // Convert SOL to lamports
        })
      );
    } else {
      // For gambling, we send the entire expected return to the fee wallet
      // The server will recognize this as a gambling deposit and add it to the user's balance
      console.log(`Adding full transfer of ${expectedReturn} SOL to ${Config.FEE_WALLET.toString()} for gambling`);
      
      // Create fee transfer instruction directly in the incineration transaction
      incinerateInstructions.push(
        SystemProgram.transfer({
          fromPubkey: Config.solWallet.publicKey,
          toPubkey: Config.FEE_WALLET,
          lamports: Math.floor(expectedReturn * 1_000_000_000), // Convert SOL to lamports
        })
      );
    }

    let signature: string;
    
    // Use Dynamic wallet if provided
    if (dynamicWallet) {
      try {
        console.log("Using Dynamic wallet to sign incineration transaction");
        
        // Get the latest blockhash
        const connection = await dynamicWallet.getConnection();
        const blockhash = await connection.getLatestBlockhash();
        
        console.log(`Instructions count: ${incinerateInstructions.length}`);
        // Debugging to inspect transaction size
        const instructionsSizes = incinerateInstructions.map((ix, index) => {
          const size = ix.data ? ix.data.length : 0;
          return `Instruction #${index}: ${size} bytes`;
        });
        console.log("Instructions sizes:", instructionsSizes);
        
        // Create the transaction message
        const messageV0 = new TransactionMessage({
          instructions: incinerateInstructions,
          payerKey: Config.solWallet.publicKey,
          recentBlockhash: blockhash.blockhash,
        }).compileToV0Message();
        
        // Create the versioned transaction
        const incinerateTxn = new VersionedTransaction(messageV0);
        
        // Check transaction size
        const serializedTx = incinerateTxn.serialize();
        console.log(`Transaction size: ${serializedTx.length} bytes`);
        
        // Solana has a transaction size limit of 1232 bytes
        const MAX_TX_SIZE = 1232;
        if (serializedTx.length > MAX_TX_SIZE) {
          throw new Error(`Transaction too large: ${serializedTx.length} bytes (max: ${MAX_TX_SIZE}). Try closing fewer accounts at once.`);
        }
        
        // Get the signer from the wallet
        console.log("Getting signer from Dynamic wallet");
        const signer = await dynamicWallet.getSigner();
        
        // Sign and send the transaction
        console.log("Calling signAndSendTransaction");
        const result = await signer.signAndSendTransaction(incinerateTxn);
        signature = result.signature;
        
        console.log(`Incineration transaction sent with signature: ${signature}`);
        
        // Wait for confirmation with a more resilient strategy
        console.log(`Waiting for incineration transaction confirmation...`);
        try {
          // Use a longer timeout and more attempts for confirmation
          const confirmationOptions = {
            signature,
            ...blockhash,
            commitment: 'confirmed',
            timeout: 60000 // 60 seconds timeout
          };
          
          const confirmationResult = await connection.confirmTransaction(confirmationOptions);
          
          if (confirmationResult.value.err) {
            throw new Error(`Transaction failed: ${confirmationResult.value.err}`);
          }
          
          console.log(`Incineration transaction confirmed successfully`);
        } catch (confirmError) {
          // Don't throw for blockheight exceeded - check transaction status directly
          if (confirmError.message && confirmError.message.includes('block height exceeded')) {
            console.log("Transaction confirmation timed out, checking status directly...");
            
            // The transaction might still be successful even if confirmation timed out
            try {
              // Wait a moment before checking status
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Check transaction status directly
              const status = await connection.getSignatureStatus(signature);
              
              if (status && status.value && !status.value.err) {
                console.log("Transaction was successful despite confirmation timeout");
                // Continue with success path
              } else if (status && status.value && status.value.err) {
                throw new Error(`Transaction failed: ${status.value.err}`);
              } else {
                throw new Error("Unable to determine transaction status");
              }
            } catch (statusError) {
              throw new Error(`Failed to check transaction status: ${statusError.message}`);
            }
          } else {
            // For other confirmation errors, throw normally
            throw confirmError;
          }
        }
      } catch (error) {
        console.error("Error signing with Dynamic wallet:", error);
        let errorMessage = "Unknown error";
        
        if (error instanceof Error) {
          errorMessage = error.message;
          
          // Check for common error types
          if (errorMessage.includes("timeout")) {
            errorMessage = "Transaction timed out. The network may be congested.";
          } else if (errorMessage.includes("rejected")) {
            errorMessage = "Transaction was rejected by the wallet.";
          } else if (errorMessage.includes("large")) {
            errorMessage = "Transaction is too large. Try incinerating fewer tokens at once.";
          } else if (errorMessage.includes("insufficient funds")) {
            errorMessage = "Insufficient funds to complete the transaction.";
          } else if (errorMessage.includes("Ve: Unexpected")) {
            // This specific error seems to occur with Dynamic wallet
            errorMessage = "Dynamic wallet error. Try again with fewer tokens or restart your browser.";
          }
        }
        
        return {
          success: false,
          message: `Error signing with Dynamic wallet: ${errorMessage}`,
          closedCount: 0,
        };
      }
    } else {
      // Use direct keypair to sign (for testing environments)
      if (!Config.solWallet.payer) {
        return {
          success: false,
          message: "No wallet keypair available for signing",
          closedCount: 0,
        };
      }
      
      const block = await Config.connection.getLatestBlockhash({
        commitment: "processed",
      });
      
      const incinerateTxMessage = new TransactionMessage({
        instructions: incinerateInstructions,
        payerKey: Config.solWallet.publicKey,
        recentBlockhash: block.blockhash,
      }).compileToV0Message();
      
      const incinerateTxn = new VersionedTransaction(incinerateTxMessage);
      incinerateTxn.sign([Config.solWallet.payer]);
      signature = bs58.encode(incinerateTxn.signatures[0]);
      
      // Send the transaction
      console.log(`Sending incineration transaction with signature ${signature}`);
      await Config.connection.sendTransaction(incinerateTxn, {
        preflightCommitment: "processed",
        skipPreflight: false,
        maxRetries: 10,
      });
      
      console.log(`Confirming incineration transaction ${signature}`);
      const incinerateRes = await Config.connection.confirmTransaction(
        {
          ...block,
          signature,
        },
        "processed"
      );
      
      if (incinerateRes.value.err) {
        console.error(`Incineration transaction ${signature} failed: ${incinerateRes.value.err}`);
        return {
          success: false,
          message: `Incineration transaction failed: ${incinerateRes.value.err}`,
          signature,
          closedCount: 0,
        };
      }
      
      console.log(`Incineration transaction ${signature} confirmed successfully`);
    }
    
    // With a single line to set the feeSignature to undefined
    const feeSignature: string | undefined = undefined;

    const batchMessage = isBatch ? 
      ` (batch of ${closedCount}/${totalEligibleAccounts} accounts)` : '';
      
    return {
      success: true,
      message: directWithdrawal 
        ? `${closedCount} token accounts successfully incinerated with fee deducted${batchMessage}` 
        : `${closedCount} token accounts successfully incinerated with funds sent to gambling${batchMessage}`,
      signature,
      feeTransferSignature: feeSignature,
      totalAmount: expectedReturn,
      closedCount,
    };
  } catch (error: any) {
    console.error("Incineration error:", error);
    return {
      success: false,
      message: `Error: ${error.message || "Unknown error"}`,
      closedCount: 0,
    };
  }
}

// Original batch incineration function (still here until refactored)
export async function batchIncinerateTokens(
  selectedTokens?: string[],
  dynamicWallet?: any,
  directWithdrawal: boolean = false,
  batchSize: number = 3, // Default to smaller batch size
  progressCallback?: (progress: number, message: string) => void
): Promise<{
  success: boolean;
  message: string;
  processedCount: number;
  totalCount: number;
  signatures: string[];
}> {
  try {
    if (!Config.solWallet.publicKey) {
      return {
        success: false,
        message: "Wallet not connected",
        processedCount: 0,
        totalCount: 0,
        signatures: []
      };
    }
    
    // Check if we have a wallet to sign transactions
    if (!dynamicWallet && !Config.solWallet.payer) {
      return {
        success: false,
        message: "No wallet available to sign transactions",
        processedCount: 0,
        totalCount: 0,
        signatures: []
      };
    }

    // Get all token accounts
    const atas = await Config.connection.getParsedTokenAccountsByOwner(
      Config.solWallet.publicKey,
      {
        programId: TOKEN_PROGRAM_ID,
      }
    );

    // Filter accounts based on selectedTokens if provided
    let accountsToProcess = atas.value;
    if (selectedTokens && selectedTokens.length > 0) {
      accountsToProcess = atas.value.filter(ata => 
        selectedTokens.includes(ata.pubkey.toString())
      );
    }
    
    const totalCount = accountsToProcess.length;
    
    if (totalCount === 0) {
      return {
        success: false,
        message: "No token accounts available to incinerate",
        processedCount: 0,
        totalCount: 0,
        signatures: []
      };
    }
    
    console.log(`Starting batch incineration of ${totalCount} tokens with batch size ${batchSize}`);
    
    // Process in batches
    const signatures: string[] = [];
    let processedCount = 0;
    let failedCount = 0;
    
    // Create batches
    const batches: any[][] = [];
    for (let i = 0; i < accountsToProcess.length; i += batchSize) {
      batches.push(accountsToProcess.slice(i, i + batchSize));
    }
    
    // Process each batch
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex];
      const batchTokenPubkeys = batch.map(ata => ata.pubkey.toString());
      
      // Update progress
      if (progressCallback) {
        const progress = Math.floor((batchIndex / batches.length) * 100);
        progressCallback(progress, `Processing batch ${batchIndex + 1} of ${batches.length}...`);
      }
      
      try {
        console.log(`Processing batch ${batchIndex + 1} of ${batches.length}`);
        
        // Call the burnTokens function from tokenBurner.ts
        const result = await burnTokens(
          batchTokenPubkeys,
          dynamicWallet,
          directWithdrawal
        );
        
        if (result.success) {
          if (result.signature) {
            signatures.push(result.signature);
          }
          processedCount += (result.closedCount || 0);
          console.log(`Batch ${batchIndex + 1} completed successfully`);
        } else {
          console.log(`Batch ${batchIndex + 1} failed: ${result.message}`);
          failedCount++;
        }
        
        // Add a delay between batches to allow network to process
        if (batchIndex < batches.length - 1) {
          console.log("Waiting between batches...");
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
      } catch (error) {
        console.error(`Error processing batch ${batchIndex + 1}:`, error);
        failedCount++;
      }
    }
    
    // Final progress update
    if (progressCallback) {
      progressCallback(100, "Processing complete");
    }
    
    // Determine final message based on results
    let message = "";
    if (processedCount === 0) {
      message = "Failed to incinerate any tokens";
      return {
        success: false,
        message,
        processedCount,
        totalCount,
        signatures
      };
    } else if (processedCount < totalCount) {
      message = `Partially completed: ${processedCount} of ${totalCount} tokens incinerated`;
    } else {
      message = `Successfully incinerated all ${totalCount} tokens`;
    }
    
    return {
      success: true,
      message,
      processedCount,
      totalCount,
      signatures
    };
  } catch (error: any) {
    console.error("Batch incineration error:", error);
    return {
      success: false,
      message: `Error: ${error.message || "Unknown error"}`,
      processedCount: 0,
      totalCount: 0,
      signatures: []
    };
  }
} 